# 实验10 - 单周期处理器综合应用设计说明

## 实验内容总结

本次实验在实验9的基础上，完成了以下改进：

### 1. 外设输入功能
- 在 top.v 中增加了 16 位拨码开关输入 `switch_value[15:0]`
- 实现了内存映射 I/O:
  - 地址 0x0000-0x3FFF: 数据存储器空间
  - 地址 0x4000: 拨码开关外设地址（16位）
  - 地址 0x4001-0xFFFFFFFF: 保留给未来外设

### 2. 新增移位指令
实现了两条 R-Type 变量移位指令：
- **SLLV** (Shift Left Logical Variable): 变量逻辑左移
- **SRLV** (Shift Right Logical Variable): 变量逻辑右移

### 3. 寄存器调试接口
保持实验9中已实现的调试功能：
- 通过 5 个按钮选择寄存器（ra_dbg[4:0]）
- 通过七段数码管显示寄存器内容（rd_dbg[31:0]的低16位）

## 实现细节

### ALU 扩展
- 将控制信号 `alucontrol` 从 3 位扩展到 4 位
- 新增操作码：
  - `4'b1000`: SLLV 左移
  - `4'b1001`: SRLV 右移

### 指令编码
- SLLV: opcode=000000, funct=000100
- SRLV: opcode=000000, funct=000110

## 测试程序

### 1. 简单拨码开关测试 (test_switch.asm)
```assembly
loop:
    lw $1, 0x4000($0)    # 从0x4000地址读取拨码开关状态
    j loop               # 死循环
```
**测试方法**：
- 拨动拨码开关
- 使用按钮选择寄存器 $1
- 在七段数码管上查看拨码开关的值是否正确

### 2. 移位指令测试 (test_shifts.asm)
测试 SLLV 和 SRLV 指令的正确性：
- 测试 8 << 2 = 32
- 测试 16 >> 1 = 8
- 测试 16 << 1 = 32
- 测试 8 >> 2 = 2

### 3. 计算器程序 (calculator.asm)

#### 功能说明
实现一个简单的计算器，通过拨码开关输入操作数和运算类型。

#### 拨码开关定义
| 位域 | 功能 | 说明 |
|------|------|------|
| [15:14] | 运算功能位 | 00=加法, 01=减法, 10=乘法, 11=除法 |
| [13:7] | 操作数 A | 7位无符号数 (0-127) |
| [6:0] | 操作数 B | 7位无符号数 (0-127) |

#### 运算实现
- **加法**: 直接使用 add 指令
- **减法**: 直接使用 sub 指令
- **乘法**: 使用重复加法实现 (循环 B 次，每次加 A)
- **除法**: 使用重复减法实现 (循环减 B，直到余数 < B)

#### 结果存储
- 计算结果存储在 **$4** 和 **$8** 寄存器中
- 可以通过按钮选择这两个寄存器，在七段数码管上显示结果

#### 程序结构
```
While(1) {
    从0x4000读取拨码开关值
    提取功能位 [15:14]
    提取操作数A [13:7]
    提取操作数B [6:0]
    根据功能位调用相应的运算子函数
    将结果存入 $4 和 $8
}
```

## 使用示例

### 示例1：计算 5 + 3
1. 设置拨码开关：
   - 位 [15:14] = 00 (加法)
   - 位 [13:7] = 0000101 (5)
   - 位 [6:0] = 0000011 (3)
   - 完整的16位值：0000000010100011 (0x00A3)
2. 使用按钮选择寄存器 $4 或 $8
3. 七段数码管应显示 8

### 示例2：计算 10 - 4
1. 设置拨码开关：
   - 位 [15:14] = 01 (减法)
   - 位 [13:7] = 0001010 (10)
   - 位 [6:0] = 0000100 (4)
   - 完整的16位值：0100001010000100 (0x4284)
2. 选择寄存器 $4 或 $8
3. 七段数码管应显示 6

### 示例3：计算 6 * 7
1. 设置拨码开关：
   - 位 [15:14] = 10 (乘法)
   - 位 [13:7] = 0000110 (6)
   - 位 [6:0] = 0000111 (7)
   - 完整的16位值：1000001100000111 (0x8307)
2. 选择寄存器 $4 或 $8
3. 七段数码管应显示 42

### 示例4：计算 20 / 4
1. 设置拨码开关：
   - 位 [15:14] = 11 (除法)
   - 位 [13:7] = 0010100 (20)
   - 位 [6:0] = 0000100 (4)
   - 完整的16位值：1100101000000100 (0xCA04)
2. 选择寄存器 $4 或 $8
3. 七段数码管应显示 5

## 代码文件说明

### 修改的文件
1. **top.v** - 顶层模块
   - 添加 switch_value 输入端口
   - 添加外设地址译码逻辑

2. **alu.v** - ALU模块
   - 扩展控制信号到4位
   - 添加 SLLV 和 SRLV 运算

3. **aludec.v** - ALU译码器
   - 扩展输出到4位
   - 添加 SLLV 和 SRLV 的译码

4. **controller.v** - 控制器
   - 更新 alucontrol 信号宽度

5. **datapath.v** - 数据通路
   - 更新 alucontrol 信号宽度

6. **mips.v** - MIPS 顶层
   - 更新 alucontrol 信号宽度

### 汇编程序文件
1. **test_switch.asm** - 简单拨码开关测试
2. **test_shifts.asm** - 移位指令测试
3. **calculator.asm** - 计算器程序

## MARS 使用说明

1. 在 MARS 中打开汇编程序文件
2. 点击 Assemble 进行汇编
3. 在 Tools → Dump Memory 导出机器码
4. 选择 Hexadecimal Text 格式
5. 将导出的十六进制代码转换为 COE 格式：
   ```
   memory_initialization_radix=16;
   memory_initialization_vector=
   指令1,
   指令2,
   ...
   指令n;
   ```
6. 使用该 COE 文件初始化 Vivado 中的 imem IP 核

## 验证要点

### 功能验证
1. ✓ 拨码开关读取功能正确
2. ✓ SLLV 和 SRLV 指令正确执行
3. ✓ 计算器的四种运算都正确
4. ✓ 寄存器调试功能正常
5. ✓ 七段数码管显示正确

### 上板测试步骤
1. 生成比特流文件
2. 下载到 Basys3 开发板
3. 按照测试示例进行验证
4. 记录实验结果和波形

## 注意事项

1. 移位量限制在 5 位（0-31），符合 MIPS 规范
2. 乘法和除法使用软件实现，执行速度较慢
3. 除法不处理除数为0的情况，需要避免
4. 七段数码管只显示结果的低16位
5. 所有运算都是无符号运算
